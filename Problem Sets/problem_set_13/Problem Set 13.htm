<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<style>
body { font: 14px Trebuchet MS; }
span.star {color: red; font: bold 18px Verdana, Arial, Helvetica, sans-serif;}
pre { color: blue; }
</style>
<title>CS112 Fall 2015: Problem Set 13</title>
</head><body>
<center>
<h1>Problem Set 13</h1>
<h2>Sorting</h2>
</center>
<hr>
<ol>
<li>Trace the mergesort algorithm on the following list:
<pre>     3, 26, 67, 25, 9, -6, 43, 82, 10, 54

</pre>
Show the resulting recursion tree, with the to-be-sorted original and
sub-lists at each node, and the number comparions for each merge.
(Assume that if there is an odd number of entries in an array,
the left part has one more entry than the right after the
split.)
<hr>
</li><li>Mergesort works well on linked lists since it doesn't need any extra
space. Given the following linked list node class:
<pre>    public class LLNode&lt;T extends Comparable&lt;T&gt;&gt;  {
       public T info;
       public LLNode&lt;T&gt; next;
       ...
    }

</pre>
complete the following method to "split" the linked list in half:
<pre>    // splits the given list in half such that the return value is 
    // a reference to the first node of the second half. Also, the 
    // "next" field of the last node in the first half is set to null.
    static &lt;T extends Comparable&lt;T&gt; LLNode&lt;T&gt; split(LLNode&lt;T&gt; list) {
       // COMPLETE THIS METHOD
    }
</pre>
<hr>
</li><li>In Problem Set 2, #5, you saw how to find the common elements in
two sorted linked lists of
integers. Here is
the header of a modified version of that method, that merges instead of finding
common elements, and will work on lists of
<tt>Comparable</tt> objects (not just <tt>int</tt>s). Complete this method
using recursion. Your method should
recycle the nodes in the original lists (no new
nodes should be created).
<pre>    // merge the lists l1 and l2 into a single linked list, whose
    // first node is referenced by the return value - no additional
    // linked list nodes are used
    static &lt;T extends Comparable&lt;T&gt;&gt; LLNode&lt;T&gt; merge(LLNode&lt;T&gt; l1, LLNode&lt;T&gt; l2) {
       // COMPLETE METHOD USING RECURSION, NO NEW NODES TO BE CREATED
    }
</pre>
Using this merge solution, and the solution to the split in the previous
problem, complete the mergesort implementation:
<pre>    // Sorts the input linked list using mergesort, and returns the front of
    // the sorted linked list. DOES NOT CREATE ANY ADDITIONAL NODES.
    public static &lt;T extends Comparable&lt;T&gt; 
    LLNode&lt;T&gt; mergesort(LLNode&lt;T&gt; list) {
       // COMPLETE THIS METHOD
    }
</pre>
<hr>
</li><li> Trace the quicksort algorithm 
on the following array:
<pre>    
   3, 26, 67, 25, 9, -6, 43, 82, 10, 54
</pre>
Use the median of the first, middle, and
last entries as the pivot to split a subarray. (If a subarray has fewer than
3 entries, use the first as the pivot.) Show the quicksort tree and
the number of comparisons at each split.
<hr>
</li><li>
<p>A <em>stable</em> sorting algorithm is one which preserves the order of duplicate elements
when sorted. For instance, suppose the following pairs of values are sorted on the
<b>first</b> value in the pair:
</p><pre>    (3,sun)  (2,mars)  (4,moon)  (3,venus)
</pre>
then the output of a stable sorting algorithm would be:
<pre>    (2,mars)  (3,sun)  (3,venus)  (4,moon)
</pre>
Notice that <tt>(3,sun)</tt> comes before <tt>(3,venus)</tt>, preserving 
the order of the input for elements that have the same sortable value of 
<tt>3</tt>, hence <em>stable</em>.

<p>However, if the output is this:
</p><pre>    (2,mars)  (3,venus)  (3,sun)  (4,moon)
</pre>
then the sorting algorithm is not stable since it does not preserve the input 
order of <tt>(3,sun)</tt> before <tt>(3,venus)</tt>.

<p>For each of insertion sort, mergesort, and quicksort, tell whether the 
algorithm is stable or not.
</p></li></ol>

</body></html>